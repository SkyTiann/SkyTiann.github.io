<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>类型系统层级</title>
    <link href="/2022/09/29/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%B1%82%E7%BA%A7/"/>
    <url>/2022/09/29/%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%B1%82%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="类型层级">类型层级</h3><p>类型层级实际上指的是，TypeScript 中所有类型的兼容关系，从最上面的 any 类型，到最底层的 never 类型。</p><h3 id="类型兼容性判断方式">类型兼容性判断方式</h3><p>类型兼容性判断格式类似于下面的格式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span> = <span class="hljs-number">22</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>如果 <strong>&lt;变量 b 的类型&gt; extends &lt;变量 a 的类型&gt;</strong> 成立，则 <strong>b 类型是 a 类型的子类型</strong>。b 的类型更精确 a 的类型更宽广。</p><h3 id="原始类型比较">原始类型比较</h3><p>一个基础类型和它们对应的字面量类型必定存在父子类型关系。但 object 有些特殊，因为它实际上代表着<strong>所有非原始类型的类型，即数组、对象与函数类型</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// true</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result1</span> = &#123; <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> &#125; <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br><span class="hljs-comment">// true</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result2</span> = [] <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br><span class="hljs-comment">// true</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result3</span> = (<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span>) <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="联合类型比较">联合类型比较</h3><p>在联合类型中，只需要符合其中一个类型，我们就可以认为实现了这个联合类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//  true</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span> = <span class="hljs-number">1</span> <span class="hljs-keyword">extends</span> <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>同一基础类型的字面量联合类型是此基础类型的子类</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//  true</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result</span> = <span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="装箱类型">装箱类型</h3><p>string 到 Object 的类型层级</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 以下都为 true</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result1</span> = <span class="hljs-built_in">string</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">String</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result2</span> = <span class="hljs-title class_">String</span> <span class="hljs-keyword">extends</span> &#123;&#125; ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result3</span> = &#123;&#125; <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result4</span> = <span class="hljs-built_in">object</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>{} extends Object</strong> 意味着，{} 是 object 和 Object 的字面量类型，是从<strong>类型信息的层面</strong>出发的，即<strong>字面量类型在基础类型之上提供了更详细的类型信息</strong>。<strong>object extends {}</strong> 和 <strong>Object extends {}<strong>则是从</strong>结构化类型系统的比较</strong>出发的。即 {} 作为一个一无所有的空对象，几乎可以被视作是所有类型的基类，万物的起源。</p><h3 id="Top-Type">Top Type</h3><p>Top Type 这里只有 any 和 unknown 这两种类型。在 TypeScript 内部代码的条件类型处理中，如果接受判断的是 any，那么会直接<strong>返回条件类型结果组成的联合类型</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result1</span> = <span class="hljs-built_in">any</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">number</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>     <span class="hljs-comment">// true | false</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result2</span> = <span class="hljs-built_in">any</span> <span class="hljs-keyword">extends</span> &#123;&#125; ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>         <span class="hljs-comment">// true | false</span><br><span class="hljs-comment">// 注意，特殊情况</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result3</span> = <span class="hljs-built_in">any</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">unknown</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>    <span class="hljs-comment">// true</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Result4</span> = <span class="hljs-built_in">unknown</span> <span class="hljs-keyword">extends</span> <span class="hljs-built_in">any</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>    <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="Bottom-Type">Bottom Type</h3><p>Bottom Type 对应的类型是 never ，它代表了“虚无”的类型，或是一个根本不存在的类型。<strong>never 是任何类型的子类型</strong>，包括它自己。</p><h3 id="其他比较场景">其他比较场景</h3><ul><li>对于基类和派生类，派生类本身就是 extends 基类得到的。</li><li>如果比较一个联合类型是否属于另一个联合类型的子集，即这个联合类型中所有成员在另一个联合类型中找到。</li></ul><h3 id="总结">总结</h3><p><img src="/images/typeHierarchy.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>TypeScript基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>结构化类型系统</title>
    <link href="/2022/09/28/%E7%BB%93%E6%9E%84%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/"/>
    <url>/2022/09/28/%E7%BB%93%E6%9E%84%E5%8C%96%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="结构化类型系统">结构化类型系统</h3><p>TypeScript的类型系统是<strong>结构化类型系统</strong>，除此之外，还有一种类型系统（<strong>标称类型系统</strong>）。结构类型的别称叫<strong>鸭子类型</strong>，其核心理念是，如果你如果看到一只鸟走起来想鸭子，游泳像鸭子，叫的也像鸭子，那么这只鸟就是鸭子。<strong>结构类型中两个类型的关系是通过对象中的属性方法来判断的</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> &#123;<br>    <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123; &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> &#123;<br>    <span class="hljs-title function_">eat</span>(<span class="hljs-params"></span>) &#123; &#125;<br>    <span class="hljs-title function_">wangwang</span>(<span class="hljs-params"></span>) &#123; &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">findCat</span>(<span class="hljs-params">cat: Cat</span>) &#123; &#125;<br><span class="hljs-title function_">findCat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>)<br></code></pre></td></tr></table></figure><p>严格意义上来说，结构化类型系统和鸭子类型系统并不完全一致，结构化类系统是<strong>基于完全的类型结构来判断类型兼容性</strong>，而鸭子类型系统是<strong>基于运行时访问的部分来决定</strong>。但由于 TypeScript 本身并不能在运行时进行类型检查，同时官方文档中同样认为这两个概念一致，因此我们可以认为这俩个概念一致。</p><h3 id="标称类型系统">标称类型系统</h3><p>标称类型系统要求，两个可以兼容的类型，其名称必须完全一致。</p><h3 id="在-TypeScript-中模拟标称类型系统">在 TypeScript 中模拟标称类型系统</h3><p><strong>类型的重要意义之一是限制了数据可用操作与实际意义</strong>。这往往是通过类型附带的<strong>额外信息</strong>来实现的（类似于元数据），要在 TypeScript 中实现，我们只需要为类型额外附加元数据即可。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TagProtector</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt;&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-attr">__tag__</span>: T<br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Nominal</span>&lt;T, U <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = T &amp; <span class="hljs-title class_">TagProtector</span>&lt;U&gt;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">CNY</span> = <span class="hljs-title class_">Nominal</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-string">&#x27;CNY&#x27;</span>&gt;<br><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">USD</span> = <span class="hljs-title class_">Nominal</span>&lt;<span class="hljs-built_in">number</span>, <span class="hljs-string">&#x27;USD&#x27;</span>&gt;<br><br><span class="hljs-keyword">const</span> cny = <span class="hljs-number">100</span> <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">CNY</span><br><br><span class="hljs-keyword">const</span> usd = <span class="hljs-number">200</span> <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">USD</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addCNY</span>(<span class="hljs-params">source: CNY, input: CNY</span>) &#123;<br>    <span class="hljs-keyword">return</span> (source + input) <span class="hljs-keyword">as</span> <span class="hljs-variable constant_">CNY</span><br>&#125;<br><br><span class="hljs-title function_">addCNY</span>(cny, cny)<br><br><span class="hljs-title function_">addCNY</span>(usd, usd)       <span class="hljs-comment">// 报错，因为私有属性 __tag__ 结构上不兼容。这里的 __tag__ 相当于元数据。</span><br><br></code></pre></td></tr></table></figure><p>这种方式本质上是通过<strong>非公开（即 private / protected）的额外属性</strong>实现了类型信息的附加，从而使得结构化类型系统将结构一致的两个类型也视为不兼容的。</p><h3 id="类型、类型系统于类型检查">类型、类型系统于类型检查</h3><p>类型：限制了数据的可用操作、意义、允许的值的集合；总的来说就是<strong>访问限制</strong>于<strong>赋值限制</strong>。在 TypeScript 中即是原始类型、对象类型、字面量类型等基础类型，以及类型别名、联合类型等经过类型编程后得到的类型。</p><p>类型系统：一组为变量、函数等结构分配、实施类型的规则，通过显示地只读或类型推导来分配类型。同时类型系统也定义了如何判断类型之间的兼容性。</p><p>类型检查：确保类型遵循类型系统下的类型兼容性，对于静态类型语言，在编译时进行，而对于动态语言，则在运行时进行。TS 就是在编译时进行类型检查的。</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>泛型</title>
    <link href="/2022/09/28/%E6%B3%9B%E5%9E%8B/"/>
    <url>/2022/09/28/%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="类型别名中的泛型">类型别名中的泛型</h3><p>如果类型别名声明了泛型，其实相当于这个类型别名是一个函数，泛型相当于函数的参数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span>&lt;T&gt; = T | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span><br></code></pre></td></tr></table></figure><p>类型别名中的泛型一般都是用来进行类型封装的。在条件类型参与的情况下，通常泛型会被作为条件类型的判断条件（<strong>T extends Condition,或者 Type extends T</strong>）以及返回值（即 : 两端的值），这也是筛选类型需要依赖的能力之一。</p><h3 id="泛型约束与默认值">泛型约束与默认值</h3><p>泛型参数与函数参数一样，同样可以有默认值。在未传入类型的情况下，会使用默认值作为参数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span>&lt;T = <span class="hljs-built_in">boolean</span>&gt; = T | <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span><br></code></pre></td></tr></table></figure><p>除了声明默认值以外，泛型还能做到一样函数做不到的事：泛型约束。也就是说，你可以要求工具类型传入的泛型参数必须符合某些条件，如果不符合就拒绝执行后面的逻辑。在泛型中，我们可以使用 <strong>extends</strong> 关键字来约束传入的泛型参数必须符合规定的要求。关于 extends，<strong>A extends B</strong> 意味着 <strong>A 是 B 的子类型</strong>，也就是 A 比 B 的类型更精确，或者说更复杂。在 TS 中，泛型参数存在默认约束。这个默认约束值在 TS3.9 版本一起是 any，之后则为 unknown。</p><h3 id="多泛型关联">多泛型关联</h3><p>多泛型参数其实就像接受更多参数的函数，其内部的运行 逻辑（类型操作）会更加抽象，表现在参数（泛型参数） 需要进行的逻辑运算（类型操作）会更加复杂。</p><h3 id="对象类型中的泛型">对象类型中的泛型</h3><p>由于泛型提供了对类型结构的复用能力。我们也经常在对象类型结构中使用泛型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Res</span>&lt;<span class="hljs-title class_">Data</span> = <span class="hljs-built_in">unknown</span>&gt; &#123;<br>    <span class="hljs-attr">code</span>: <span class="hljs-built_in">number</span><br>    error?: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">data</span>: <span class="hljs-title class_">Data</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数中的泛型">函数中的泛型</h3><p>为函数声明一个泛型参数 T，并将参数的类型与返回值类型指向这个泛型参数。在这个函数接收到参数时，<strong>T 会自动地被填充为这个参数的类型</strong>。在基于参数类型填充时，其类型信息会被推断到尽可能精确的程度。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> handle&lt;T&gt;(<span class="hljs-attr">input</span>: T): T &#123;&#125;  <span class="hljs-comment">// 相当于 T = typeof input</span><br><span class="hljs-keyword">const</span> handle = &lt;T&gt;(<span class="hljs-attr">input</span>: T): <span class="hljs-function"><span class="hljs-params">T</span> =&gt;</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="Class中的泛型">Class中的泛型</h3><p>Class中泛型消费方是属性、方法或装饰器等。同时Class内的方法还可以再声明自己独有的泛型参数。</p><h3 id="内置方法中的泛型">内置方法中的泛型</h3><p>TypeScript 中为非常多的内置对象都预留了泛型坑位，如 Promise 和 Array 等。</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类型安全</title>
    <link href="/2022/09/27/%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8/"/>
    <url>/2022/09/27/%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="类型安全的类型工具">类型安全的类型工具</h3><p>除了类型的创建以外，类型的安全保障同样属于类型工具的能力之一。两个主要用于类型安全的类型工具： <strong>类型查询操作符</strong>与<strong>类型守卫</strong></p><h3 id="类型查询操作符：typeof">类型查询操作符：typeof</h3><p>TypeScript中存在<strong>两种功能不同的 typeof 操作符</strong>。一种是返回 “string” / “number” / “undefined” / “object” 这类字符串的typeof（值层面），需要使用值层面的变量接收。还有一种是返回类型的 typeof 操作符（类型层面），需要使用类型变量接收。绝大多数情况下，typeof返回的类型是<strong>最窄的推导程度</strong>（即到字面量类型的级别）。在逻辑代码中使用的 typeof 一定是 JavaScript 中的 typeof，而类型代码（如类型标注、类型别名等）中的一定是类型查询的 typeof。注意，<strong>类型查询操作符后面是不允许使用表达式的</strong>。</p><h3 id="类型守卫">类型守卫</h3><p>在 TypeScript 中提供了非常强大的类型推导能力，它会随着你的代码逻辑不断尝试收窄类型，这一能力称为<strong>类型的控制流分析（类型推导）</strong>。一般在 if else 语句或 switch case 语句中出现。<strong>类型控制流分析做不到跨函数上下文来进行类型的信息收集</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// TS 只能推断出 isString 是一个返回布尔值的函数，而并不知道这个布尔值的具体含义</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isString</span>(<span class="hljs-params">str: <span class="hljs-built_in">unknown</span></span>): <span class="hljs-built_in">boolean</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> str === <span class="hljs-string">&#x27;string&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) &#123; <br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isString</span>(str))&#123;<br>        <span class="hljs-keyword">type</span> A = <span class="hljs-keyword">typeof</span> str     <span class="hljs-comment">// A = string | number</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了解决这个问题，TypeScript 引入了 <strong>is关键字</strong>来显示的提供类型信息。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 这时，TS 就直到了这个布尔值的含义了，为 true 就说明 str 的类型是字符串</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isString</span>(<span class="hljs-params">str: <span class="hljs-built_in">unknown</span></span>): str is <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> str === <span class="hljs-string">&#x27;string&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) &#123; <br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isString</span>(str))&#123;<br>        <span class="hljs-keyword">type</span> A = <span class="hljs-keyword">typeof</span> str     <span class="hljs-comment">// A = string</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>isString 函数被称为类型守卫</strong>。<strong>is关键字 + 预期类型</strong>，即如果这个函数成功返回为 true ，那么 is 关键字前这个入参的类型，就会<strong>被这个类型守卫调用方后续的类型控制流分析收集到</strong>。</p><h3 id="基于-in-与-instanceof-的类型保护">基于 in 与 instanceof 的类型保护</h3><p>in操作符可以通过 <strong>key in object</strong> 的方式来判断 key 是否存在说 object 或其原型链上（返回 true 说明存在）。这种类型保护需要组成这个联合类型的每一个类型都具有一个独一无二的属性（<strong>可辨识属性</strong>），这种联合类型也被称为<strong>可辨识联合类型</strong>。<strong>这个可辨识属性可以是结构层面的，还可以是共同属性的字面量类型差异</strong>。</p><p>基于可辨识属性的差异：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-attr">propA</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">propFoo</span>: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Bar</span> &#123;<br>    <span class="hljs-attr">propA</span>: <span class="hljs-built_in">string</span>,<br>    <span class="hljs-attr">propBar</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">DemoFunc</span>(<span class="hljs-params">input: Foo | Bar</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;propFoo&#x27;</span> <span class="hljs-keyword">in</span> input) &#123;<br>        <span class="hljs-keyword">type</span> A = <span class="hljs-keyword">typeof</span> input       <span class="hljs-comment">// A = Foo</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">type</span> B = <span class="hljs-keyword">typeof</span> input       <span class="hljs-comment">// B = Bar</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>基于共同属性的字面量类型差异:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;Foo&#x27;</span>,<br>    <span class="hljs-attr">propA</span>: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Bar</span> &#123;<br>    <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;Bar&#x27;</span>,<br>    <span class="hljs-attr">propA</span>: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">DemoFunc</span>(<span class="hljs-params">input: Foo | Bar</span>) &#123;<br>    <span class="hljs-keyword">if</span> (input.<span class="hljs-property">key</span> === <span class="hljs-string">&#x27;Foo&#x27;</span>) &#123;<br>        <span class="hljs-keyword">type</span> A = <span class="hljs-keyword">typeof</span> input       <span class="hljs-comment">// A = Foo</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">type</span> B = <span class="hljs-keyword">typeof</span> input       <span class="hljs-comment">//  B = Bar</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了 in 以外，还有存在一个功能类似于 typeof 与 in 的操作符：<strong>instanceof</strong>，它判断的是原型级别的关系。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-title function_">funcFoo</span>(<span class="hljs-params"></span>) &#123; &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span> &#123;<br>    <span class="hljs-title function_">funcBar</span>(<span class="hljs-params"></span>) &#123; &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">DemoFunc</span>(<span class="hljs-params">input: Foo | Bar</span>) &#123;<br>    <span class="hljs-keyword">if</span> (input <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Foo</span>) &#123;<br>        <span class="hljs-keyword">type</span> A = <span class="hljs-keyword">typeof</span> input<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">type</span> B = <span class="hljs-keyword">typeof</span> input<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型断言守卫">类型断言守卫</h3><p>断言是一旦不符合断言，就会抛出错误。断言守卫和类型守卫最大的不同点在于，在判断条件不通过时，断言守卫需要<strong>抛出错误</strong>，类型守卫只需要剔除掉预期的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">title</span>: <span class="hljs-built_in">any</span> = <span class="hljs-string">&#x27;title&#x27;</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">assertIsNumber</span>(<span class="hljs-params">val: <span class="hljs-built_in">any</span></span>): asserts val is <span class="hljs-built_in">number</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> val !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Not a Number!!&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-title function_">assertIsNumber</span>(title)<br><br><span class="hljs-keyword">type</span> A = <span class="hljs-keyword">typeof</span> title<br></code></pre></td></tr></table></figure><h3 id="接口合并">接口合并</h3><p>接口可以使用继承（extends）进行合并，在继承时子接口可以声明同名属性，但并不能覆盖掉父接口中的此属性。子接口中的属性类型需要能够兼容（extends）父接口中的属性类型。</p><p>类似的，如果直接声明多个同名接口，虽然接口会进行合并，但这些同名属性的类型任然需要兼容。</p><p>接口和类型别名直接的合并也是一样。如接口继承类型别名，类型别名使用交叉类型合并接口。</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS类型工具</title>
    <link href="/2022/09/25/TS%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7/"/>
    <url>/2022/09/25/TS%E7%B1%BB%E5%9E%8B%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="类型工具">类型工具</h3><p>按照使用方式来划分，类型工具分为三类：<strong>操作符、关键字与专用语法</strong>。如果是按照使用目的来划分，类型工具可以分为<strong>类型创建</strong>与<strong>类型安全保护</strong>。</p><h3 id="类型别名">类型别名</h3><p>通过使用<strong>type</strong>关键字声明一个类型别名。类型别名的作用主要是为了一组类型或一个特定类型结构的封装，以便在其他地方进行复用。</p><p>类型别名还可以作为工具类型。**工具类型同样基于类型别名，只是多了个泛型。<strong>工具类型能够接收泛型，实现了</strong>更灵活的类型创建功能。**一般不会直接使用工具类型来做类型标注，而是再度声明一个新的类型。</p><h3 id="联合类型（-）与交叉类型（-）">联合类型（|）与交叉类型（&amp;）</h3><p>交叉类型，需要符合这里的所有类型，才可以说是实现了这个交叉类型，即 A &amp; B，需要同时满足 A 与 B 两个类型才行。如果是两个原始类型的合并，则类型为 never：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">BoolAndStr</span> = <span class="hljs-built_in">boolean</span> &amp; <span class="hljs-built_in">string</span>  <span class="hljs-comment">// never</span><br></code></pre></td></tr></table></figure><p>如果是两个联合类型组成的交叉类型，就是两边联合类型的交集。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">UnionIntersection</span> = (<span class="hljs-number">1</span> | <span class="hljs-number">2</span> | <span class="hljs-number">3</span>) &amp; (<span class="hljs-number">1</span> | <span class="hljs-number">2</span>)  <span class="hljs-comment">//  1 | 2</span><br></code></pre></td></tr></table></figure><p>虽然对象类型和原始数据类型的交集，按集合逻辑应该是空集，但在 TS 中最终表现为<strong>装箱</strong>后于对象类型的属性并集。这实际上完全是为了另一个目的：nominal（名义），即使得“类型别名”（type）具有唯一性（或者叫 tag ）。</p><h3 id="索引类型">索引类型</h3><p>索引类型包含三个部分：<strong>索引签名类型、索引类型查询</strong>与<strong>索引类型访问</strong>。实际上这三者都是独立的类型工具。唯一共同点是，<strong>它们都通过索引的形式来进行类型操作</strong>，但索引签名类型是<strong>声明</strong>，后两者则是<strong>读取</strong>。</p><h3 id="索引签名类型">索引签名类型</h3><p>索引签名类型主要指的是再接口或类型别名中，通过以下语法来快速声明一个键值类型一致的类型结构：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">AllStringTypes</span> &#123;<br>    [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">AllStringTypes</span> = &#123;<br>    [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span><br>&#125;<br><span class="hljs-comment">// 这两个同名的类型不可写到一起</span><br></code></pre></td></tr></table></figure><p>在实现这个类型结构的变量中只能声明字符串类型的键。但由于在 JavaScript 中，会将数字索引访问转换为字符串索访问。因此，在字符串索引签名中我们仍然可以声明数字类型的键。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">AllStringTypes</span> = &#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;Tian&#x27;</span><br>    [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个类型中的属性必须符合索引签名的类型，如果不符合，就会报错</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">AllStringTypes</span> = &#123;<br>    <span class="hljs-comment">// Property &#x27;a&#x27; of type &#x27;boolean&#x27; is not assignable to &#x27;string&#x27; index type &#x27;string&#x27;.</span><br>    <span class="hljs-attr">a</span>: <span class="hljs-built_in">boolean</span><br>    [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>索引签名类型的常见场景是在重构 JavaScript 代码时，为内部属性较多的对象声明一个 any 的索引签名类型，以此来<strong>暂时支持对类型未明确属性的访问</strong>，并在后续一点点补全类型。</p><h3 id="索引类型查询">索引类型查询</h3><p>索引类型查询使用 <strong>keyof</strong> 操作符，<strong>它可以将对象中的所有键转换为对应的字面量类型，然后再组合成联合类型</strong>。你还可以直接 keyof any 来产生一个联合类型，它会由所有可用作对象键值的类型组成。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span> = keyof <span class="hljs-built_in">any</span>    <span class="hljs-comment">// string | number | symbol</span><br></code></pre></td></tr></table></figure><h3 id="索引类型访问">索引类型访问</h3><p>与 JavaScript 访问对象一样，索引类型访问也使用同样的方式，不过是在类型层面上的。索引类型查询的本质其实就是，<strong>通过键的字面量类型访问这个键对应的键值类型</strong>。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">NumberRecord</span> &#123;<br>    [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span> = <span class="hljs-title class_">NumberRecord</span>[<span class="hljs-built_in">string</span>]     <span class="hljs-comment">// Foo == number</span><br></code></pre></td></tr></table></figure><h3 id="映射类型">映射类型</h3><p>映射类型的主要作用<strong>即是基于键名映射到键值类型</strong>。使用 keyof 获得这个对象类型的键名组成字面量联合类型，然后通过映射类型（关键字 in）将这个联合类型的每一个成员映射出来。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-attr">propA</span>: <span class="hljs-built_in">number</span><br>    <span class="hljs-attr">propB</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">propC</span>: <span class="hljs-built_in">boolean</span><br>&#125;<br><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">MapAllType</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = &#123;<br>    [K <span class="hljs-keyword">in</span> keyof T]: T[K]<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Bar</span> = <span class="hljs-title class_">MapAllType</span>&lt;<span class="hljs-title class_">Foo</span>&gt;  <br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">等价于</span><br><span class="hljs-comment">type Bar = &#123;</span><br><span class="hljs-comment">    propA: number</span><br><span class="hljs-comment">    propB: string</span><br><span class="hljs-comment">    propC: boolean</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>需要注意，这里只有 K in 属于映射类型的语法，keyof T 属于 keyof 操作符，[K in keyof T] 的 [] 属于索引签名类型，T[K] 属于索引类型访问。</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>any、unknown、never 与类型断言</title>
    <link href="/2022/09/24/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/"/>
    <url>/2022/09/24/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<h3 id="any-类型">any 类型</h3><p>TypeScript 中提供了一个内置类型 any，来表示所谓的任意类型。any类型几乎无所不能，它可以在声明后再次接受任意类型的值，同时可以被赋值给任意其它类型的变量。它能兼容所有类型，也能够被所有类型兼容。为了避免 any 的乱用，有以下使用技巧：</p><ul><li>如果是类型不兼容报错导致你使用 any，考虑用类型断言代替。</li><li>如果是类型太复杂导致你不想全部声明而使用any，考虑将这一处的类型去断言为你需要的最简类型。</li><li>如果你是想表达一个未知类型，更合理的方式是使用 unknown。</li></ul><h3 id="unknown-类型">unknown 类型</h3><p>unknown 类型和 any 类型有些类似，一个 unknown 类型的变量可以再次赋值为任意其它类型，但一个 unknown 类型的变量只能赋值给 any 与 unknown 类型的变量。对 unknown 类型进行属性访问，需要进行类型断言。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> <span class="hljs-attr">unknownVar</span>: <span class="hljs-built_in">unknown</span><br>(unknownVar <span class="hljs-keyword">as</span> &#123; <span class="hljs-attr">foo</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125; &#125;).<span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure><h3 id="never-类型">never 类型</h3><p>never 类型不携带任何的类型信息，因此会在联合类型中被直接移除。在编程语言的类型系统中，never 类型被称为 Bottom Type，是整个类型系统中最底层的类型。和 null、undefined 一样，它是所有类型的子类型，但只有 never 类型的变量可以赋值给另一个 never 类型的变量。通常我们不会显示的声明一个 never 类型，它主要被类型检查所使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">justThrow</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">never</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>在类型流的分析中，一旦一个返回值类型为 never 的函数被调用，那么下方的代码都会被视为无效的代码。我们也可以显示的利用它来进行类型检查。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">strOrNumOrBool</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | <span class="hljs-built_in">boolean</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> strOrNumOrBool === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;str!&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> strOrNumOrBool === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;num!&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> strOrNumOrBool === <span class="hljs-string">&quot;boolean&quot;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;bool!&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`Unknown input type: <span class="hljs-subst">$&#123;strOrNumOrBool&#125;</span>`</span>);<br>&#125;<br></code></pre></td></tr></table></figure>  <h3 id="类型断言">类型断言</h3><p>类型断言能够显式告知类型检查程序当前这个变量的类型，可以进行类型分析地修正、类型。它其实就是一个将变量的已有类型更改为新的指定类对象的操作，基本语法是 <strong>变量 as NewType</strong>。类型断言的正确使用方式是，在 TypeScript 类型分析不正确或不符合预期时，将其断言为正确类型。需要注意，类型断言应当是在迫不得已的情况下使用的。</p><h3 id="双重断言">双重断言</h3><p>如果在使用类型断言时，原类型与断言类型之间差异过大，TypeScript 会给你一个类型报错：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Sky&quot;</span>;<br><br><span class="hljs-comment">// 从 X 类型 到 Y 类型的断言可能是错误的</span><br>(str <span class="hljs-keyword">as</span> &#123; <span class="hljs-attr">handler</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125; &#125;).<span class="hljs-title function_">handler</span>()<br></code></pre></td></tr></table></figure><p>此时就可以先断言到 unknown 类型，再断言到预期类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">str</span>: <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;Sky&quot;</span>;<br><br>(str <span class="hljs-keyword">as</span> <span class="hljs-built_in">unknown</span> <span class="hljs-keyword">as</span> &#123; <span class="hljs-attr">handler</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125; &#125;).<span class="hljs-title function_">handler</span>();<br></code></pre></td></tr></table></figure><h3 id="非空断言">非空断言</h3><p>非空断言其实就是类型断言的简化，它使用 ! 语法，即 <strong>obj!.func()!.prop</strong> 的形式标记前面的一个声明一点是非空的（实际上就是剔除了 null 和 undefined 类型）。非空断言的常见场景有 document.querySelector、Array.find等。<br>使用类型断言，我们还可以在保留类型提示的前提下，不那么完整地实现这个结构。</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数与class中的类型</title>
    <link href="/2022/09/22/%E5%87%BD%E6%95%B0%E4%B8%8Eclass%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/09/22/%E5%87%BD%E6%95%B0%E4%B8%8Eclass%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="函数的类型签名">函数的类型签名</h3><p>函数的类型就是描述了函数入参类型与函数返回值类型，无需去管具体实现。函数的类型同样使用 : 的语法进行标注。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 方式一： 函数声明的方式进行类型标注</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">age:<span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span>&#123;<br>    <span class="hljs-keyword">return</span> age<br>&#125;<br><span class="hljs-comment">// 方式二： 函数表达式的方式进行类型标注</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-function">(<span class="hljs-params">age:<span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function"><span class="hljs-params">age</span> =&gt;</span> age<br></code></pre></td></tr></table></figure><p>TypeScript中的函数签名与ES6中的箭头函数很像，这是设计者特意这样设计的，目的是为了方便理解。在方式二的声明中，代码可读性非常差，一般不推荐这么使用，要么<strong>直接在函数中进行参数和返回值的类型声明</strong>，要么<strong>使用类型别名将函数声明抽离出来</strong>。</p><p>我们甚至可以使用 interface 来进行函数声明，这时的 interface 被称为 <strong>Callable Interface</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 方式三</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Fun</span> &#123;<br>    (<span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="void类型">void类型</h3><p>在 TypeScript 中，一个没有返回值的函数，其返回类型应该被标记为 void 而不是 undefined。因为在 TypeScript 中，undefined 类型是一个有实际意义的类型值，而 void 才代表着空的、没有意义的类型值。以下例子用 undefined 比 void 要好：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>): <span class="hljs-literal">undefined</span>&#123;<br>    <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="可选参数与-rest-参数">可选参数与 rest 参数</h3><p>函数中的可选参数与对象中的可选参数是一致的，使用 ？ 来描述一个可选参数。但需要注意的是，<strong>可选参数必须位于必选参数之后</strong>。rest 参数只包含那些没有对应形参的实参，是 Array 实例。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">age: <span class="hljs-built_in">number</span>, ...rest: [<span class="hljs-built_in">string</span>, <span class="hljs-built_in">number</span>]</span>) &#123; &#125;<br><span class="hljs-title function_">foo</span>(<span class="hljs-number">11</span>, <span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-number">22</span>)<br></code></pre></td></tr></table></figure><h3 id="重载">重载</h3><p><strong>如果想要实现入参关联的返回值类型</strong>，就可以使用 TypeScript 提供的函数重载签名。需要注意，拥有多个重载声明的函数在被调用时，是按照重载的声明顺序往下查找的。</p><h3 id="异步函数、Generator函数等类型签名">异步函数、Generator函数等类型签名</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 异步函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">asyncFun</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">void</span>&gt; &#123; &#125;<br><span class="hljs-comment">// 生成器函数</span><br><span class="hljs-keyword">function</span>* <span class="hljs-title function_">generatorFun</span>(): <span class="hljs-title class_">Iterable</span>&lt;<span class="hljs-built_in">void</span>&gt; &#123; &#125;<br><span class="hljs-comment">// 异步生成器函数 AsyncIterable&lt;void&gt;要配置 tsconfig &quot;target&quot;: &quot;ES2018&quot;</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">asyncGenFun</span>(): <span class="hljs-title class_">AsyncIterable</span>&lt;<span class="hljs-built_in">void</span>&gt; &#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="类与类成员的类型签名">类与类成员的类型签名</h3><p>类的主要结构只有<strong>构造函数、属性、方法、和访问修饰符</strong>。需要注意，<strong>setter 方法不允许进行返回值的类型标注</strong>。类可以通过<strong>类声明</strong>和<strong>类表达式</strong>的方式创建，规则如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 类声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span> &#123; &#125;<br><span class="hljs-comment">// 类表达式</span><br><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">class</span> &#123; &#125;<br></code></pre></td></tr></table></figure><h3 id="修饰符">修饰符</h3><p>修饰符一共有四种，它们分别是：public / private / protected / readonly。这些修饰符应用的位置在成员（属性或方法）命名前。成员的默认修饰符为 public。通过构造函数为类成员赋值的方式有些复杂，我们可以在构造函数中对参数应用访问修饰符：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">foo</span> &#123; <br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">public</span> arg1: <span class="hljs-built_in">number</span>,<span class="hljs-keyword">public</span> arg2: <span class="hljs-built_in">boolean</span></span>) &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态成员">静态成员</h3><p>在 TypeScript 中，可以使用 static 关键字来标识一个成员为静态成员，在类的内部静态成员无法通过 this 来访问，而是通过 <strong>类名.成员名</strong> 的方式访问。<strong>静态成员直接被挂载在函数体上，而实例成员被挂在到原型上</strong>。</p><h3 id="继承、实现、抽象类">继承、实现、抽象类</h3><p>TypeScript 中使用 <strong>extends</strong> 关键字来实现继承。在派生类（子类）中通过 <strong>super</strong> 访问基类（父类）中的方法，通过 <strong>override</strong> 关键字来覆盖基类中的方法。抽象类描述了一个类中应当有哪些成员，一个抽象方法描述了这一方法在实际实现中的结构。抽象类使用 <strong>abstract</strong> 关键字声明，抽象类无法被实例化。普通类可以通过关键字 <strong>implements</strong> 来实现一个抽象类。需要注意，TypeScript 中无法声明静态抽象成员。接口也可以描述类的结构，<strong>Newable Interface</strong> 可以描述一个类的结构（类似与描述函数结构的 Callable Interface）：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123; &#125;<br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">FooStruct</span> &#123;<br>    <span class="hljs-title function_">new</span>(): <span class="hljs-title class_">Foo</span><br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">NewableFoo</span>: <span class="hljs-title class_">FooStruct</span><br><br><span class="hljs-keyword">const</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NewableFoo</span>()<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>TypeScript基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字面量类型与枚举类型</title>
    <link href="/2022/09/22/%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/09/22/%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="字面量类型">字面量类型</h3><p>字面量类型主要包括<strong>字符串字面量类型</strong>、<strong>数字字面量类型</strong>、<strong>布尔字面量类型</strong>和<strong>对象字面量类型</strong>。字面量类型比原始类型要更加精确。因为原始类型的值可以包括任意的同类型的值，而字面量类型要求的是<strong>值级别的字面量一致</strong>，值不相同则类型不相同，也就是原始类型的细化。</p><h3 id="联合类型">联合类型</h3><p>联合类型可以理解为，它代表了<strong>一组类型的可用集合</strong>，只要最终赋值的类型属于联合类型中的成员之一，就可以认为符合这个联合类型。联合类型中的成员类型使用 | 连接起来。可以把 | 理解为编程中的或，只要符合或中的任意一个条件，表达式就为真。联合类型的几个注意的地方：</p><ul><li>对于联合类型中的函数类型，需要使用 () 包裹起来</li><li>函数类型并不存在字面量类型</li><li>可以在联合类型中进一步嵌套联合类型，但这些嵌套的联合类型最终都会被展平到第一级中</li></ul><h3 id="字面量类型与联合类型">字面量类型与联合类型</h3><p>通常来说，字面量类型会配合联合类型一起使用，从而获得更精确地类型推导</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Response</span> &#123;<br>    <span class="hljs-attr">code</span>: <span class="hljs-number">10000</span> | <span class="hljs-number">10001</span> | <span class="hljs-number">10002</span>;<br>    <span class="hljs-attr">status</span>: <span class="hljs-string">&quot;success&quot;</span> | <span class="hljs-string">&quot;failure&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用了联合类型来代替 number 和 string 类型，使得推导出来的类型更加精确</p><h3 id="对象字面量类型">对象字面量类型</h3><p>对象字面量类型就是一个对象类型的值，这也就意味着这个对象的值<strong>全都</strong>为字面量值：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tian&#x27;</span>    <span class="hljs-comment">// 这里的 &#x27;Tian&#x27; 是类型而不是字符串</span><br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>         <span class="hljs-comment">// 同理</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对象字面量类型在实际开发中的使用较少，只需要了解</p><p>需要注意的是，<strong>无论是原始类型的字面量类型还是对象类型的字面量类型，它们的本质都是类型而不是值</strong>。它们在编译时同样会被擦除，同时也被存储在内存中的类型空间而不是值空间</p><h3 id="枚举">枚举</h3><p>如果你没有声明枚举的值，它默认使用数字枚举，并且从 0 开始，以 1 递增：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Items</span> &#123;<br>    <span class="hljs-title class_">Foo</span>, <span class="hljs-title class_">Bar</span>, <span class="hljs-title class_">Baz</span>  <br>    <span class="hljs-comment">// Foo = 0; Bar = 1; Baz = 2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果你只为某一个成员指定了枚举值，那么之前未赋值成员任然会使用从 0 开始递增的方式，之后的成员则会开始从枚举值递增。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Items</span> &#123;<br>    <span class="hljs-title class_">Foo</span>, <span class="hljs-title class_">Bar</span> = <span class="hljs-number">299</span>, <span class="hljs-title class_">Baz</span>   <br>    <span class="hljs-comment">// Foo = 0; Bar = 299; Baz = 300</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在数字型枚举中，可以使用延迟求值的枚举值，比如函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">returnNum</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-number">100</span> + <span class="hljs-number">499</span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Items</span> &#123;<br>    <span class="hljs-title class_">Foo</span> = <span class="hljs-title function_">returnNum</span>(),<br>    <span class="hljs-title class_">Bar</span> = <span class="hljs-number">599</span>,<br>    <span class="hljs-title class_">Baz</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意，<strong>如果你使用了延迟求值，那么没有使用延迟求值的枚举成员必须放在使用常量枚举值声明的成员之后，或者放在第一位。</strong></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 错误示范</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Items</span> &#123;<br>    <span class="hljs-title class_">Foo</span> = <span class="hljs-title function_">returnNum</span>(),<br>    <span class="hljs-title class_">Baz</span>,    <span class="hljs-comment">// Enum member must have initializer.</span><br>    <span class="hljs-title class_">Bar</span> = <span class="hljs-number">599</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>TypeScript 中也可以同时使用字符串和数字作为枚举值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Items</span> &#123;<br>    <span class="hljs-title class_">Foo</span> = <span class="hljs-number">299</span>,<br>    <span class="hljs-title class_">Bar</span> = <span class="hljs-string">&#x27;Tian&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>枚举和对象的重要差异在于，对象是单项映射的，只能通过键找到对应的值。而枚举是双向映射的（只有数字才可以双向映射，字符串枚举成员任然只会进行单次映射），既可以通过键找到值，还可以通过值找到键</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Items</span> &#123;<br>    <span class="hljs-title class_">Foo</span>, <span class="hljs-title class_">Bar</span>, <span class="hljs-title class_">Baz</span> <br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title class_">FooKey</span> = <span class="hljs-title class_">Items</span>[<span class="hljs-number">0</span>]     <span class="hljs-comment">// &#x27;Foo&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">FooValue</span> = <span class="hljs-title class_">Items</span>.<span class="hljs-property">Foo</span>  <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>枚举会被编译成以下的JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Items</span>;<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params">Items</span>) &#123;<br>    <span class="hljs-title class_">Items</span>[<span class="hljs-title class_">Items</span>[<span class="hljs-string">&quot;Foo&quot;</span>] = <span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Foo&quot;</span>;<br>    <span class="hljs-title class_">Items</span>[<span class="hljs-title class_">Items</span>[<span class="hljs-string">&quot;Bar&quot;</span>] = <span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Bar&quot;</span>;<br>    <span class="hljs-title class_">Items</span>[<span class="hljs-title class_">Items</span>[<span class="hljs-string">&quot;Baz&quot;</span>] = <span class="hljs-number">2</span>] = <span class="hljs-string">&quot;Baz&quot;</span>;<br>&#125;)(<span class="hljs-title class_">Items</span> || (<span class="hljs-title class_">Items</span> = &#123;&#125;));<br><span class="hljs-comment">// 注：Items[&quot;Foo&quot;] = 0 会返回 0 这个数字，这只是一种简写方式</span><br></code></pre></td></tr></table></figure><h3 id="常量枚举">常量枚举</h3><p>常量枚举和枚举相似，只是声明时多了 const。对于常量枚举，只能通过枚举成员访问枚举值（而不能通过枚举值访问枚举成员）。同时，在编译产物中并不会存在一个额外的辅助对象，对枚举值的访问会被<strong>直接内联替换为枚举的值</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>TypeScript基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原始类型与对象类型</title>
    <link href="/2022/09/21/%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/"/>
    <url>/2022/09/21/%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="原始类型值">原始类型值</h3><p>在JavaScript中，原始类型的值有7种，它们分别是 number/string/boolean/undefined/null/Symbol(ES6)/bigint(ES11)。在TypeScript中它们都有对应的类型标注。</p><h3 id="null与undefined">null与undefined</h3><p>它们在作为类型时，表示的是一个具体意义的类型值。如果没有开启 strictNullChecks 检查的情况下的话，这两个类型默认会被当做<strong>其他类型的子类型</strong>。</p><h3 id="void类型">void类型</h3><p>void类型一般用来描述内部没有 return 语句，或者没有显示 return 一个值的函数的返回值（作用在函数上）。</p><h3 id="数组的类型标注">数组的类型标注</h3><p>数组的类型标注有两种形式：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">number</span>[] = []<br><span class="hljs-keyword">const</span> <span class="hljs-attr">bar</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = []<br></code></pre></td></tr></table></figure><p>这两种方式完全是等价的,推荐使用第一种。如果在开发的时候，数组的长度是固定不变的话，使用元组（Tuple）来代替数组是个不错的选择。元组不可超出索引最大值进行访问，而数组可以，数组超过最大索引后并不会报错，而是返回undefined，元组则直接报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo[<span class="hljs-number">4</span>])     <span class="hljs-comment">// undefined</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">bar</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar[<span class="hljs-number">4</span>])     <span class="hljs-comment">// Tuple type &#x27;[number, number, number]&#x27; of length &#x27;3&#x27; has no element at index &#x27;4&#x27;.</span><br></code></pre></td></tr></table></figure><p>元组支持可选成员,只需要在成员后面加上 ‘?’ 即可。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>?, <span class="hljs-built_in">number</span>?] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>被标记为可选的成员，其类型是一个联合类型 number? == number | undefined。对于这个元组的 length 属性的类型，也是一个联合类型 1 | 2 | 3 。</p><p>元组的可读性不好，于是在 TypeScript4.0 之后，有了具名元组，可以为元组的成员打上一个标记，用于增强元组的可读性。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: [<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>, male?: <span class="hljs-built_in">boolean</span>] = [<span class="hljs-string">&#x27;Tian&#x27;</span>, <span class="hljs-number">18</span>]<br></code></pre></td></tr></table></figure><p>注意：对于可选属性，‘?’ 要加载标记的后面而不是类型的后面。</p><p>关于隐式越界访问，对于数组而言，由于类型层面并不知道数组中有多少个元素，所以并不会报错。但对于元组而言，由于类型系统知道元组成员的个数，可以在隐式越界时提出警告。</p><h3 id="对象的类型标注">对象的类型标注</h3><p>前面的类型都是原始类型，但在JavaScript中使用最频繁的数据结构是对象。TypeScript 中使用 interface 来描述一个对象的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span><br>    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span><br>    <span class="hljs-attr">male</span>: <span class="hljs-built_in">boolean</span><br>&#125;<br><span class="hljs-comment">// 每一行后面的逗号可有可无</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: <span class="hljs-title class_">Person</span> = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tian&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">18</span>,<br>    <span class="hljs-attr">male</span>: <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对于这个接口来说，实现这个接口的对象必须实现接口描述的所有成员，即不能多，也不可少。对于接口而言，我们还可以使用属性修饰符来进行修饰，常见的修饰符有两种：<strong>可选（?）</strong> 与 <strong>只读 （readonly）</strong>。可选与数组的情况相同，但只读与数组有区别：</p><ul><li>对象可以只标记其中的一个属性为只读，但数组和元组只能将整个标记为只读</li><li>一旦数组被标记为只读，则会禁用所有能改变数组的方法（如：push，pop）</li></ul><h3 id="type-与-interface">type 与 interface</h3><p>一般来说，推荐使用的方式是，interface用来描述对象、类的结构，而类型别名用来将一个函数签名、一组联合类型、一个工具类型等等抽离成一个完整独立的类型</p><h3 id="object、Object与">object、Object与{}</h3><p>首先复习一下原型链<br><img src="/images/instanceof.jpg" alt=""><br>原型链的顶端是 Object 和 Function ，这也就意味着所有原始类型（JavaScript中原始类型默认为装箱类型，其实也是对象）与对象类型最终都指向 Object ，<strong>在 TypeScript 中就表现为 Object 包含所有的类型</strong>。和 Object 类似的还有 Boolean、String、Symbol、这几个<strong>装箱类型（Boxed Types）</strong>，本质上是对 Object 类型的收窄。<strong>在任何情况下都不应该使用这些装箱类型</strong>。</p><p>object 的引入就是为了解决对 Object 类型的错误使用，它代表<strong>所有非原始类型的类型，比如数组、对象与函数这些类型（也即是引用类型）</strong></p><p>Object 包含了除 Top Type（any 和 unknown） 以外的所有类型（基础类型、函数类型等）<br>object 包含了所有非原始类型的类型，即数组，对象与函数类型。</p><p>对象字面量 {} ，虽然可以作为变量的类型，但实际上<strong>无法对这个变量进行任何赋值操作</strong>，只进不出。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-attr">foo</span>: &#123;&#125; = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Tian&#x27;</span> &#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">name</span>)   <span class="hljs-comment">// Property &#x27;name&#x27; does not exist on type &#x27;&#123;&#125;&#x27;.</span><br></code></pre></td></tr></table></figure><p>为了更好的区分 object、Object 和 {} ，做以下总结：</p><ul><li>任何时候都不要使用 Object 以及类似的装箱类型。</li><li>当不确定某个变量的具体类型时，但可以确定它不是原始类型，可以使用 object。但更推荐进一步区分，也就是使用 <em>Record&lt;string,unknow&gt;</em> 或者 <em>Recode&lt;string,any&gt;</em> 表示对象，<em>unknow[]</em> 或 <em>any[]</em> 表示数组， <em>(…args: any[]) =&gt; any</em> 表示函数。</li><li>同样要避免使用 {}。{} 意味着任何非  null/undefined 的值。从这个层面上看，使用它和使用 any 一样恶劣。</li></ul>]]></content>
    
    
    <categories>
      
      <category>TypeScript基础知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树</title>
    <link href="/2022/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="二叉树的基本概念">二叉树的基本概念</h3><p>二叉树是 n （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>≥</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">n \geq 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>）个结点的有限集合<br>1.或者为空二叉树，即 n = 0<br>2.或者由一个<strong>根结点</strong>和两个互不相交的被称为根的<strong>左子树</strong>和<strong>右子树</strong>组成。左子树和右子树又分别是一颗二叉树。</p><h3 id="二叉树的五种状态">二叉树的五种状态</h3><p><img src="/images/fiveStates.png" alt=""></p><h3 id="满二叉树">满二叉树</h3><p>一颗高度为h，且含有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9324em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 个节点的二叉树。<br>特点：</p><ul><li>只有最后一层有叶子节点</li><li>不存在度为 1 的节点</li><li>按层序从 1 开始编号，节点 i 的左孩子为 2i，右孩子为 2i + 1；节点 i 的父节点为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌊</mo><mrow><mi>i</mi><mo>÷</mo><mn>2</mn></mrow><mo stretchy="false">⌋</mo></mrow><annotation encoding="application/x-tex">\lfloor {i \div 2} \rfloor</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌊</span><span class="mord"><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">2</span></span><span class="mclose">⌋</span></span></span></span></li></ul><h3 id="二叉树的特点">二叉树的特点</h3><p>1.每个节点最多有两个孩子（二叉树中不存在度大于2的节点）<br>2.子树有左右之分，其次序不能颠倒<br>3.二叉树可以是空集合，根可以有空的左子树或空的右子树</p><h3 id="二叉树的性质">二叉树的性质</h3><p>1.在二叉树的第i层上<strong>至多</strong>有2^{i-1}个节点（i &gt;= 1）</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树</title>
    <link href="/2022/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/"/>
    <url>/2022/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h3 id="树数据结构">树数据结构</h3><p>树是一种分层数据的抽象模型。现实生活中最常见到的树的例子是家谱，如下图所示：<br><img src="/images/genealogy.png" alt=""></p><h3 id="树的相关术语">树的相关术语</h3><p>如下图所示，这是一颗树：<br><img src="/images/MyTree.png" alt=""></p><p>位于树顶部的结点叫做<strong>根结点（11）</strong>。树中的每个元素都叫做结点，除根结点没有父结点以外，每一个结点都有一个唯一的父结点。结点分为<strong>内部结点（分支结点）<strong>和</strong>外部结点（叶子结点）</strong>。至少有一个子结点的结点称为内部结点。没有子元素的结点称为外部结点（叶子结点）。</p><p>一个结点可以有祖先和后代。一个结点（除根结点）的祖先包括父结点、祖父结点、曾祖父结点等。一个结点的后代包括子结点、孙子结点、曾孙结点等。</p><p>树的基本概念：树是 n 个结点的有限集合，n = 0 时，称为空树，这是一种特殊情况。在任意一颗非空树中应该满足</p><ul><li>有且仅有一个特定的称为根的结点</li><li>当 n &gt; 1 时，其余结点可分为 m （m &gt; 0）个互不相交的有限集合 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">T_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">T_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>…<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>m</mi></msub></mrow><annotation encoding="application/x-tex">T_m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，其中每个集合本身又是一颗树，并且称为根结点的子树</li><li>树是一种递归定义的数据结构</li></ul><p><strong>子树</strong>，是由结点和他的后代构成的。例如，根结点（11）是由两个子树构成的。他们分别是结点（7）和它的后代构成的子树，结点（15）和它的后代构成的子树。</p><p><strong>结点的深度</strong>，取决于它祖先结点的数量。比如，结点（3）有3个祖先结点，所以它的深度为3。</p><p>树的高度取决于所有结点深度的最大值。</p><p><strong>空树</strong>–结点数为0的树</p><p><strong>边</strong>–结点与结点之间的连接线</p><p><strong>结点的度</strong>：当前结点有几个孩子结点</p><p><strong>树的度</strong>：各结点的度的最大值</p><p>有序树：树中结点的各子树从左至右是有次序的，不能互换<br>无序树：树中结点的各子树从左至右是无次序的，可以互换</p><p><strong>森林</strong>：是 m （m &gt;= 0） 颗互不相交的树的集合</p><h3 id="树的性质">树的性质</h3><p>1.结点数 = 总度数 + 1</p><p>2.度为 m 的树、m 叉树的区别</p><table><thead><tr><th>度为 m 的树</th><th>m 叉树</th></tr></thead><tbody><tr><td>任意结点的度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> （最多 m 个孩子）</td><td>任意结点的度 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≤</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">\leq m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span> （最多 m 个孩子）</td></tr><tr><td>至少有一个结点度 = m （有 m 个孩子）</td><td>允许所有结点的度都 &lt; m</td></tr><tr><td>一定是非空树，至少有 m + 1 个结点</td><td>可以是空树</td></tr></tbody></table><p>3.度为 m 的树第 i 层至多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">m^{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span> 个结点 （<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≥</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i \geq 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7955em;vertical-align:-0.136em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">≥</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>）</p><p>4.高度为 h 的 m叉树至多有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><msup><mi>m</mi><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><mrow><mi>m</mi><mo>−</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{m^h - 1}{m - 1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4463em;vertical-align:-0.4033em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0429em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.927em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4033em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>个结点。等比数列求和公式：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mrow><mi>a</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><msup><mi>q</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><mrow><mn>1</mn><mo>−</mo><mi>q</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{a(1-q^n)}{1-q}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.4911em;vertical-align:-0.4811em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mopen mtight">(</span><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.4811em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p><p>5.高度为 h 的 m 叉树至少有 h 个结点。高度为 h、度为 m 的树至少有 h+m-1 个结点。</p><p>6.具有 n 个节点的 m 叉树的最小高度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mi>m</mi></msub><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">(</mo><mi>m</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil {log_m(n(m-1)+1)} \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span><span class="mclose">⌉</span></span></span></span></p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
